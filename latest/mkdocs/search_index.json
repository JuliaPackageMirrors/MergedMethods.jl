{
    "docs": [
        {
            "location": "/", 
            "text": "MergedMethods\n\n\nMerge methods from different modules.\n\n\n\n\nContents\n\n\n\n\nMergedMethods\n\n\nContents\n\n\nInstallation\n\n\nIndex\n\n\nPublic Interface\n\n\n\n\n\n\n\n\n\n\nInstallation\n\n\nThis package is registered in \nMETADATA.jl\n and so can be installed using \nPkg.add\n\n\nPkg\n.\nadd\n(\nMergedMethods\n)\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nMergedMethods\n\n\nMergedMethods.@kwmerge\n\n\nMergedMethods.@merge\n\n\n\n\n\n\nPublic Interface\n\n\n#\n\n\nMergedMethods\n \n \nModule\n.\n\n\n\n\nMerge functions from different modules into a single function.\n\n\nThis module provides two exported macros that can be used to merge different functions.\n\n\n\n\n@merge\n\n\n@kwmerge\n\n\n\n\n#\n\n\nMergedMethods.@merge\n \n \nMacro\n.\n\n\n\n\nMerge functions from different modules.\n\n\nSignature\n\n\n@\nmerge\n(\nfunc\n,\n \nmodules\n...\n)\n\n\n\n\n\n\nExamples\n\n\nmodule\n \nA\n\n\n\ntype\n T\n \nend\n\n\n\nf\n(::\nT\n)\n \n=\n \nT\n\n\n\nend\n\n\n\nmodule\n \nB\n\n\n\ntype\n T\n \nend\n\n\n\nf\n(::\nT\n)\n \n=\n \nT\n\n\n\nend\n\n\n\n@\nmerge\n \nf\n \nA\n \nB\n\n\n\nf\n(\nA\n.\nT\n())\n \n==\n \nA\n.\nT\n\n\nf\n(\nB\n.\nT\n())\n \n==\n \nB\n.\nT\n\n\n\n\n\n\nIf several modules provide methods suitable for the specified arguments then the first listed, in the above example it would be \nA\n, is selected.\n\n\nGenerated Code\n\n\n@merge\n uses \n@generated\n to build specialised code for each tuple of arguments passed to the merged function. The resulting code will typically have little to no overhead due to inlining of the dispatch function.\n\n\nmodule\n \nA\n\n\n\nf\n(\nx\n::\nInt\n,\n \ny\n::\nFloat64\n)\n \n=\n \nx\n \n+\n \n2\ny\n\n\n\nend\n\n\n\nmodule\n \nB\n\n\n\nf\n(\nx\n::\nFloat64\n,\n \ny\n::\nInt\n)\n \n=\n \nx\n \n-\n \n3\ny\n\n\n\nend\n\n\n\n@\nmerge\n \nf\n \nA\n \nB\n\n\n\ntest\n(\nx\n,\n \ny\n)\n \n=\n \nf\n(\nx\n,\n \ny\n)\n \n+\n \nf\n(\ny\n,\n \nx\n)\n\n\n@\ncode_llvm\n \ntest\n(\n1\n,\n \n1.0\n)\n\n\n\n\n\n\ndefine\n \ndouble\n \n@julia_test_24571\n(\ni64\n,\n \ndouble\n)\n \n{\n\n\ntop:\n\n  \n%2\n \n=\n \ncall\n \ndouble\n \n@\njulia_*.1245\n(\ni64\n \n2\n,\n \ndouble\n \n%1\n)\n\n  \n%3\n \n=\n \ncall\n \ndouble\n \n@\njulia_+_24572\n(\ni64\n \n%0\n,\n \ndouble\n \n%2\n)\n\n  \n%4\n \n=\n \nmul\n \ni64\n \n%0\n,\n \n3\n\n  \n%5\n \n=\n \ncall\n \ndouble\n \n@julia_-.1288\n(\ndouble\n \n%1\n,\n \ni64\n \n%4\n)\n\n  \n%6\n \n=\n \nfadd\n \ndouble\n \n%3\n,\n \n%5\n\n  \nret\n \ndouble\n \n%6\n\n\n}\n\n\n\n\n\n\nSee also:\n \n@kwmerge\n.\n\n\n#\n\n\nMergedMethods.@kwmerge\n \n \nMacro\n.\n\n\n\n\nVariant of \n@merge\n with support for passing keyword arguments.\n\n\nSignature\n\n\n@\nkwmerge\n(\nfunc\n,\n \nmodules\n...\n)\n\n\n\n\n\n\nExamples\n\n\n@\nkwmerge\n \nf\n \nA\n \nB\n\n\nf\n(\n1\n,\n \na\n \n=\n \n2\n,\n \nb\n \n=\n  \n3\n)\n\n\n\n\n\n\nNote:\n\n\nThis macro should only be used when keywords are actually needed since the generated code will probably not be as efficient as that of \n@merge\n.\n\n\nSee also:\n \n@merge\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#mergedmethods", 
            "text": "Merge methods from different modules.", 
            "title": "MergedMethods"
        }, 
        {
            "location": "/#contents", 
            "text": "MergedMethods  Contents  Installation  Index  Public Interface", 
            "title": "Contents"
        }, 
        {
            "location": "/#installation", 
            "text": "This package is registered in  METADATA.jl  and so can be installed using  Pkg.add  Pkg . add ( MergedMethods )", 
            "title": "Installation"
        }, 
        {
            "location": "/#index", 
            "text": "MergedMethods  MergedMethods.@kwmerge  MergedMethods.@merge", 
            "title": "Index"
        }, 
        {
            "location": "/#public-interface", 
            "text": "#  MergedMethods     Module .   Merge functions from different modules into a single function.  This module provides two exported macros that can be used to merge different functions.   @merge  @kwmerge   #  MergedMethods.@merge     Macro .   Merge functions from different modules.  Signature  @ merge ( func ,   modules ... )   Examples  module   A  type  T   end  f (:: T )   =   T  end  module   B  type  T   end  f (:: T )   =   T  end  @ merge   f   A   B  f ( A . T ())   ==   A . T  f ( B . T ())   ==   B . T   If several modules provide methods suitable for the specified arguments then the first listed, in the above example it would be  A , is selected.  Generated Code  @merge  uses  @generated  to build specialised code for each tuple of arguments passed to the merged function. The resulting code will typically have little to no overhead due to inlining of the dispatch function.  module   A  f ( x :: Int ,   y :: Float64 )   =   x   +   2 y  end  module   B  f ( x :: Float64 ,   y :: Int )   =   x   -   3 y  end  @ merge   f   A   B  test ( x ,   y )   =   f ( x ,   y )   +   f ( y ,   x )  @ code_llvm   test ( 1 ,   1.0 )   define   double   @julia_test_24571 ( i64 ,   double )   {  top: \n   %2   =   call   double   @ julia_*.1245 ( i64   2 ,   double   %1 ) \n   %3   =   call   double   @ julia_+_24572 ( i64   %0 ,   double   %2 ) \n   %4   =   mul   i64   %0 ,   3 \n   %5   =   call   double   @julia_-.1288 ( double   %1 ,   i64   %4 ) \n   %6   =   fadd   double   %3 ,   %5 \n   ret   double   %6  }   See also:   @kwmerge .  #  MergedMethods.@kwmerge     Macro .   Variant of  @merge  with support for passing keyword arguments.  Signature  @ kwmerge ( func ,   modules ... )   Examples  @ kwmerge   f   A   B  f ( 1 ,   a   =   2 ,   b   =    3 )   Note:  This macro should only be used when keywords are actually needed since the generated code will probably not be as efficient as that of  @merge .  See also:   @merge .", 
            "title": "Public Interface"
        }
    ]
}